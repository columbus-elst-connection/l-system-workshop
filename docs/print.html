<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>L-Systems</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A compendium to the L-Systems workshop">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="outline.html"><strong aria-hidden="true">2.</strong> Outline</a></li><li><a href="l-system.html"><strong aria-hidden="true">3.</strong> L-system</a></li><li><ol class="section"><li><a href="lsystem/Aristid.html"><strong aria-hidden="true">3.1.</strong> Aristid Lindenmayer</a></li><li><a href="lsystem/algae.html"><strong aria-hidden="true">3.2.</strong> Algae</a></li></ol></li><li><a href="parser.html"><strong aria-hidden="true">4.</strong> Parsers</a></li><li><ol class="section"><li><a href="parser/what.html"><strong aria-hidden="true">4.1.</strong> What is a Parser?</a></li><li><a href="parser/type.html"><strong aria-hidden="true">4.2.</strong> Looking at the type</a></li><li><a href="parser/function.html"><strong aria-hidden="true">4.3.</strong> Functions are Parsers!</a></li><li><a href="parser/character.html"><strong aria-hidden="true">4.4.</strong> Parsing a char</a></li><li><a href="parser/any.html"><strong aria-hidden="true">4.5.</strong> Parsing any char</a></li></ol></li><li><a href="interpreter.html"><strong aria-hidden="true">5.</strong> Interpreter</a></li><li><ol class="section"><li><a href="interpreter/what.html"><strong aria-hidden="true">5.1.</strong> What is an Interpreter</a></li></ol></li><li><a href="renderer.html"><strong aria-hidden="true">6.</strong> Renderer</a></li><li><ol class="section"><li><a href="renderer/what.html"><strong aria-hidden="true">6.1.</strong> What is a Renderer</a></li></ol></li><li><a href="dependencies.html">Working with Dependencies</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">L-Systems</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>This book is a compendium to the <a href="https://en.wikipedia.org/wiki/L-system">L-systems</a> workshop.</p>
<p>This book and the workshop will introduce you to L-systems, allowing you to play
and understand them.</p>
<p>Understanding means that you get the opportunity to create a program that reads,
evaluates and renders an L-system. We will start from scratch and teach you all
the necessary tools and techniques to finish.</p>
<p>This book serves as a guide during your journey. A trusty companion that cheers
you on, helps you when you are stuck and can turn to when your motivation is
low.</p>
<h2><a class="header" href="#not-at-a-workshop" id="not-at-a-workshop">Not at a workshop?</a></h2>
<p>This book is written to be self contained. The only downside of not being in a
workshop is missing the ability to ask questions and getting a quick answer.</p>
<p>There still is the ability to ask questions, it might just take some time before
we can answer them. Try one of the following means of communication</p>
<ul>
<li><a href="https://join.slack.com/t/col-els-con/shared_invite/enQtNjUzNTYyNDY2ODIxLTRjZTBkMzlkNzMyNjMwNzg0Njg3MzhlZDQ3ZjE0OWI2OGFhMWYyNDhiZTVmZTFiMzI5NmZhOWQ2ZWIxZjUwZTQ">Slack</a></li>
<li><a href="https://github.com/columbus-elst-connection/workshop/issues">GitHub Issues</a></li>
<li><a href="mailto://daan.v.berkel.1980+l-system@gmail.com">Mail</a></li>
</ul>
<h1><a class="header" href="#outline" id="outline">Outline</a></h1>
<p>There are various ways of learning and we want to enable you to choose your path
through the material. Below you can find the main sections that we will address
during this workshop.</p>
<p>It is possible to progress through the sections in any order you want. We have
setup things in such a way that you can rely on our code so long as yours is not
ready.</p>
<h2><a class="header" href="#l-systems" id="l-systems">L-systems</a></h2>
<p>This section teaches you what <a href="https://en.wikipedia.org/wiki/L-system">L-systems</a> are, trains you how to
create them, and allows you to play with them.</p>
<p>Describing a L-system is one thing. Teaching a computer how to work with
L-systems is another. The next sections are major parts in the software that
allows you to explore L-systems.</p>
<h2><a class="header" href="#parser" id="parser">Parser</a></h2>
<p>A <a href="https://en.wikipedia.org/wiki/Parsing">parser</a> is a</p>
<blockquote>
<p>software component that takes input data (frequently text) and builds a data
structure – often some kind of parse tree, abstract syntax tree or other
hierarchical structure, giving a structural representation of the input while
checking for correct syntax. </p>
</blockquote>
<p>This section focuses on parsing a L-system. We do this by creating our own
<a href="https://en.wikipedia.org/wiki/Parser_combinator">Parser Combinator framework</a> that we use to read an L-system
and turn it into a data structure that we can use.</p>
<h2><a class="header" href="#interpreter" id="interpreter">Interpreter</a></h2>
<p>Once you have defined an L-system, you probably would like to do something with
it. The <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreter</a> helps with this goal. It diligently executes the
instructions described by the L-system informing interested parties what has
happened.</p>
<p>The interpreter is the workhorse of our program. Although it is the centerpiece
of our software, it is a quit simple machine.</p>
<h2><a class="header" href="#renderer" id="renderer">Renderer</a></h2>
<p>An L-system without a &quot;picture&quot; is as a Christmas tree without decorations. It
still is instructive, but is sure isn't as much fun.</p>
<p>In this section we explore various way of make a &quot;picture&quot; for our L-system.
There are various ways of turning the L-system into meaningful artifact. Making
an image is surely not the only one.</p>
<h1><a class="header" href="#l-system" id="l-system">L-system</a></h1>
<p>This section teaches you all about what <a href="https://en.wikipedia.org/wiki/L-system">L-systems</a> are.</p>
<p>Read about Aristid Lindenmayer and why he invented his system. Explore the rich
language and it's beautiful images.</p>
<h1><a class="header" href="#aristid-lindenmayer" id="aristid-lindenmayer">Aristid Lindenmayer</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Aristid_Lindenmayer">Aristid Lindenmayer</a> was a Hungarian biologist. He lived from 1925
until 1989. He studied biology and chemistry at the university of Budapest.
Lindenmayer got his Ph.D. from the University of Michigan before accepting a
position as professor in Philosophy of Life Sciences and Biology at the
University of Utrecht.</p>
<p><img src="lsystem//image/lindenmayer.jpg" alt="Aristid Lindenmayer" /></p>
<h1><a class="header" href="#algae" id="algae">Algae</a></h1>
<p>Aristid Lindenmayer introduces a system of substitutions that would later bear his name. He did this in a set of two articles; <em>Mathematical Models for Cellular Interactions in Development</em>. As the title implies it offers a mathematical theory to model growth in certain type of cells. Stripping away the mathematics his article described an example that modeled algae. A more modern description follows below.</p>
<p>We will study <em>words</em>, i.e. a sequence of symbols, over an <em>alphabet</em>. In our example we take our alphabet to be the symbols <em>A</em>, and <em>B</em>. We will examine a series of words. In the algae example we are starting with the word <em>A</em>. 
With the current word in the series, we replace each symbol with a sequence of symbols and concatenating the sub-sequences in a new word. In our example we will replace each occurring symbol <em>A</em> with the sequence <em>AB</em>, and each occurring symbol <em>B</em> with the sequence <em>A</em>.</p>
<p>Below you find the first few iterations of this process.</p>
<ol>
<li><em>A</em>, our starting word.</li>
<li><em>AB</em>, because the single <em>A</em> is replaced with <em>AB</em>.</li>
<li><em>ABA</em>, because the single <em>A</em> is replaced with <em>AB</em> and the <em>B</em> is replaced with <em>A</em>.</li>
<li><em>ABAAB</em>, because each <em>A</em> is replaced with <em>AB</em> and each <em>B</em> is replaced with <em>A</em>.</li>
</ol>
<p>In the above model the symbol <em>A</em> is a model for a mature cell, ready to divide itself. The division however is asymmetric. It allows the original cell to comfortable remain in place, making place for a young cell <em>B</em>. In its stead, the young cell <em>B</em> first must mature to and become an <em>A</em> cell before it can start reproducing itself.</p>
<p>Although this is a simple model. A lot can be learned from this. For an few examples, see the exercises.</p>
<h2><a class="header" href="#exercises" id="exercises">Exercises</a></h2>
<ol>
<li>Extend the example with the a few iterations.</li>
<li>Count the number of symbols in each word of the series. Guess what number comes next.</li>
<li>Count the number of <em>A</em>'s and the number of <em>B</em>'s separately. What do you get.</li>
<li>We will number the words in our series, \(W_{0}\) for our start word, \(W_{1}\), for the next, \(W_{2}\) for the one after that, etcetera. Pick any number, let's say 4. Notice how \(W_{4}\), i.e. <em>ABAAB</em> is the concatenation of <em>ABA</em>, which is \(W_{3}\), and <em>AB</em>, which is \(W_{2}\). In other words \(W_{4}=W_{3}W_{2}\).</li>
</ol>
<ul>
<li>Check if something similar holds for \(W_{3}\) and \(W_{5}\).</li>
<li>Does this property, i.e. \(W_{k} = W_{k-1}W_{k-2}\) always hold?</li>
</ul>
<h1><a class="header" href="#parser-1" id="parser-1">Parser</a></h1>
<p>In the L-system section you have had the opportunity to learn about and play with
Lindenmayer systems. The Parser section starts our journey of creating our own
software to explore L-systems.</p>
<p>The journey starts with teaching the computer about <code>.ls</code> files and what we
describe with them. </p>
<p>Make sure to look in to <a href="dependencies.html">working with dependencies</a> to find out
how to incorporate your code into the project.</p>
<h1><a class="header" href="#what-is-a-parser" id="what-is-a-parser">What is a Parser?</a></h1>
<p>A <a href="https://en.wikipedia.org/wiki/Parsing">parser</a> is a</p>
<blockquote>
<p>software component that takes input data (frequently text) and builds a data
structure – often some kind of parse tree, abstract syntax tree or other
hierarchical structure, giving a structural representation of the input while
checking for correct syntax.</p>
</blockquote>
<p>In our case we want to teach the computer to understand <code>.ls</code> files. This is our
<em>input data</em>. Although this input is convenient for us, it is just a sequences of
bytes to a computer.</p>
<p>What we want is an L-system that we can manipulate. That is our <em>data
structure</em>. Parsing is what brings us from our input data to our L-system.</p>
<h2><a class="header" href="#parser-framework" id="parser-framework">Parser framework</a></h2>
<p>We will be building our own Parser framework. I.e. we will build the
infrastructure that allows us to create a custom parser. We will use our
framework to create a specific parser that reads in our <code>.ls</code> files and create
the L-system for us.</p>
<h2><a class="header" href="#parser-combinator" id="parser-combinator">Parser Combinator</a></h2>
<p>Our framework will be based on the concept of Parser Combinators. A Parser
Combinator is a</p>
<blockquote>
<p>higher-order function that accepts several parsers as input and returns a new
parser as its output. In this context, a parser is a function accepting strings
as input and returning some structure as output, typically a parse tree or a set
of indices representing locations in the string where parsing stopped
successfully.</p>
</blockquote>
<p>If this does not really makes sense to you. Keep reading and soon you will be an
expert Parser Combinatorist.</p>
<h1><a class="header" href="#looking-at-the-type" id="looking-at-the-type">Looking at the type</a></h1>
<p>Before we start out it is good to think what we want to achieve. This allows us
to reason about the constraints and capture those in our types.</p>
<p>A parser reads input and transforms that into some data structure. This already
provides us with a decision. I.e. what type is our input?</p>
<p>We want to make things easy for our selves and since string literals have type
<code>&amp;str</code> we our going to pick that as our input type.</p>
<p>We don't really know what output type is going to be, put we do know that the
parser could fail. Take a look at the following code</p>
<pre><code class="language-lsystem">F -&gt; FF
</code></pre>
<p>Although it looks like an L-system, it not quite an L-system. At least not in
the form we expect in the L-system section. The arrow is wrong!</p>
<p>Because the data-structure could be anything, we better make it a generic
parameter. So our first guess for the output type could be
<code>Result&lt;T, ParserError&gt;</code>, where <code>ParserError</code> is defined as</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, PartialEq)]
pub enum ParseError {
    GenericError,
}
#}</code></pre></pre>
<h2><a class="header" href="#combinator" id="combinator">Combinator</a></h2>
<p>Although our first guess isn't that far off, it is lacking some flexibility.
What we like to achieve is to easily combine different kind of parsers into a
more complex one.</p>
<p>With this goal in mind, we would like to pass information about what part of the
input still needs parsing. Because we want to feed that into a different parser,
that type should be <code>&amp;str</code>, our input type.</p>
<p>So our second guess is <code>Result&lt;(T, &amp;str), ParseError&gt;</code>.</p>
<p>A Parser returns either a tuple of the parsed result and the rest of the
input, or it returns an error. </p>
<h2><a class="header" href="#trait" id="trait">Trait</a></h2>
<p>We now can create a <code>trait</code> that describes the contract our parsers have. It is
little more than our consideration, with the correct use of lifetimes to keep
the compiler happy.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Parser&lt;'a, T&gt; {
    fn parse(&amp;self, input: &amp;'a str) -&gt; Result&lt;(T, &amp;'a str), ParseError&gt;;
}
#}</code></pre></pre>
<p>So a Parser is anything that has a <code>parse</code> method of the right signature.</p>
<h2><a class="header" href="#exercises-1" id="exercises-1">Exercises</a></h2>
<ol>
<li>Implement the <code>Parser</code> trait and the <code>ParseError</code> enum.</li>
</ol>
<h1><a class="header" href="#functions-are-parsers" id="functions-are-parsers">Functions are Parsers!</a></h1>
<p>With our <code>Parser</code> trait in place we can start implementing it. Thinking about
the trait one implementation springs to mind.</p>
<p>If we have a function, or a lambda expression for that matter, that has the
right signature. I.e. accepts a <code>&amp;str</code> and returns a 
<code>Result&lt;(T, &amp;str), ParseError&gt;</code>, in some sense it is a parser. We just have to
apply the function! </p>
<p>Let's start with that implementation.</p>
<pre><code>impl &lt;'a, T, F&gt; Parser&lt;'a, T&gt; for F where F: Fn(&amp;'a str) -&gt; Result&lt;(T, &amp;'a str), ParseError&gt; {
    fn parse(&amp;self, input: &amp;'a str) -&gt; Result&lt;(T, &amp;'a str), ParseError&gt; {
        self(input)
    }
}
</code></pre>
<h2><a class="header" href="#exercises-2" id="exercises-2">Exercises</a></h2>
<ol>
<li>Write the implementation of the <code>Parser</code> trait for <code>Fn(&amp;'a str) -&gt; Result&lt;(T, &amp;'a str), ParserError&gt;</code>.</li>
</ol>
<h1><a class="header" href="#parsing-a-char" id="parsing-a-char">Parsing a <code>char</code></a></h1>
<p>In this chapter we will spend some time explaining how to create a <code>Parser</code>
capable of parsing a <code>char</code>. We will go through all the motions and explain
all the steps.</p>
<p>Our goal for this chapter is to make the following test pass.</p>
<pre><code>    #[test]
    fn parse_a_character() {
        let input = &quot;ABCD&quot;;
        let parser = character('A');

        let actual = parser.parse(input);

        let expected = Ok(('A', &quot;BCD&quot;));
        assert_eq!(actual, expected);
    }
</code></pre>
<p>So let's get started.</p>
<h2><a class="header" href="#character" id="character">Character</a></h2>
<p>Thinking about the challenge of parsing a <code>char</code> one could notice the following
things. Giving a certain <code>&amp;str</code>, we need to</p>
<ol>
<li>Check if it starts with the correct character.</li>
<li>If it does, return it and the rest of the <code>&amp;str</code>.</li>
<li>If it does not, report an error.</li>
</ol>
<p>In order to be able to implement the <code>Parser</code> trait, there first needs to be
something we can implement the <code>Parser</code> trait for. This thing will need to keep
track of what character to parse.</p>
<p>We will use a struct <code>Character</code> for that. We will give it a field that tracks
the intended character to match.</p>
<pre><code>pub struct Character {
  character_to_match: char,
}
</code></pre>
<h2><a class="header" href="#impl-parser" id="impl-parser">Impl Parser</a></h2>
<p>Let's implement <code>Parser</code> for the <code>Character</code> struct. We will be guided by the outline above</p>
<pre><code>impl&lt;'a&gt; Parser&lt;'a, char&gt; for Character {
    fn parse(&amp;self, input: &amp;'a str) -&gt; Result&lt;(char, &amp;'a str), ParseError&gt; {
        if input.starts_with(self.character_to_match) {
            Ok((self.character_to_match, &amp;input[1..]))
        } else {
            Err(ParseError::ExpectingCharacter(self.character_to_match))
        }
    }
}
</code></pre>
<p>The first two lines are the signature needed to adhere to the traits contract.
Next we check if the input starts with the character to match. If it does, we
return a succesful parse with the matched character and the remaining input.
Otherwise we announce an error, which we also need to add to our <code>ParseError</code>
enum.</p>
<pre><code>#[derive(Debug, PartialEq)]
pub enum ParseError {
    GenericError,
    ExpectingCharacter(char),
}
</code></pre>
<h2><a class="header" href="#constructor" id="constructor">Constructor</a></h2>
<p>It is convenient to create a <em>constructor</em> for our <code>Character</code> struct. This eases the
burden of creating a <code>Character</code> parser.</p>
<pre><code>impl Character {
    pub fn new&lt;'a&gt;(character_to_match: char) -&gt; impl Parser&lt;'a, char&gt; {
        Self { character_to_match }
    }
}
</code></pre>
<p>Notice the return type of our constructor. It hides the implementation details.
It only tells you that you can expect to get something that implements a <code>Parser</code>
that returns a <code>char</code> on success.</p>
<p>This allows us greater flexibility in the future. We can easily change the structure
of Character without changing the constructor, or code that relies on it.</p>
<h2><a class="header" href="#factory" id="factory">Factory</a></h2>
<p>An other convience is the use of a <a href="https://en.wikipedia.org/wiki/Factory_method_pattern">factory</a>. A factory is a pattern that hides the
details of how an struct is created. It serves yet an other purpose, to use a name that
reflects the intention, instead of exposing the mechanism of construction.</p>
<p>So instead of writing <code>Character::new('a')</code>, we want to write <code>character('a')</code>. Under
the covers this is done by using the constructor for <code>Character</code>.</p>
<pre><code>pub fn character&lt;'a&gt;(character_to_match: char) -&gt; impl Parser&lt;'a, char&gt; {
    Character::new(character_to_match)
}
</code></pre>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>Since the <code>Character</code> parser is an example of how parser can be created we are going to
summarize the steps.</p>
<ol>
<li>Choose a datatype that allows the parser to do it's job.</li>
<li>Implement <code>Parser</code> for it.</li>
<li>Create a <em>constructor</em>.</li>
<li>Create a factory.</li>
</ol>
<p>The <code>Character</code> parse was build of a struct. Implementing <code>Parser</code> was done by translating
the parsing process into rust. And constructor and factory were created for ease of use.</p>
<h2><a class="header" href="#exercises-3" id="exercises-3">Exercises</a></h2>
<ol>
<li>Implement the <code>Character</code> parser.</li>
<li>Write some tests to check your implementation.</li>
</ol>
<h1><a class="header" href="#parsing-any-char" id="parsing-any-char">Parsing any <code>char</code></a></h1>
<p>In a previous chapter we created a parser that could parse a single
specific character. An other useful parser would parse a string
would start with any of a group of characters.</p>
<p>To be more precise. Let's say that we would like to parse a <code>&amp;str</code> if
it starts with a digit. What we would like to achieve is to pass the 
following test</p>
<pre><code>    #[test]
    fn parse_any_digit() {
        let input = &quot;0123&quot;;
        let parser = any(|c: char| c.is_ascii_digit());

        let actual = parser.parse(input);

        let expected = Ok(('0', &quot;123&quot;));
        assert_eq!(actual, expected);
    }
</code></pre>
<p>We will go through all the motions of creating a parser once more.</p>
<h2><a class="header" href="#any" id="any">Any</a></h2>
<p>We will create a struct that will contain everything it needs to
make our wish come through. For this we need to be able to store
a <em>predicate</em>, a function that will decide on the characters we
expect.</p>
<pre><code>pub struct Any&lt;F&gt; where F: Fn(char) -&gt; bool + Sized {
    predicate: F,
}
</code></pre>
<p>Here <code>F</code> is an alias for the <code>Fn(char) -&gt; bool + Sized</code> type.
Our predicate, is a function that accepts a character and tells
use if it does or does not fall in our category. The <code>Sized</code> restriction
is necessary because we want to store it in our field.</p>
<h2><a class="header" href="#impl-parser-1" id="impl-parser-1">Impl Parser</a></h2>
<p>Next we our going to implement the <code>Parser</code> trait. The basic idea is,
given our input</p>
<ol>
<li>Check if it starts with a character from our category.</li>
<li>If it does, return it and the rest of the input.</li>
<li>If it does not, return an error.</li>
</ol>
<p>The difference with the <code>Character</code> parser is that <code>String</code> does not have
a convenience method like <code>starts_with</code> that we can use. Instead we can use
an <em>iterator</em> over the characters of our input. See below for details.</p>
<pre><code>impl&lt;'a, F&gt; Parser&lt;'a, char&gt; for Any&lt;F&gt; where F: Fn(char) -&gt; bool + Sized {
    fn parse(&amp;self, input: &amp;'a str) -&gt; Result&lt;(char, &amp;'a str), ParseError&gt; {
        let character = input.chars().next();
        match character {
            Some(c) =&gt; {
                if (self.predicate)(c) {
                    Ok((c, &amp;input[1..]))
                } else {
                    Err(ParseError::ExpectingPredicate)
                }
            },

            None =&gt; {
                Err(ParseError::EndOfInput)
            }
        }
    }
}
</code></pre>
<p>We ask our input for an iterator over its characters. Match on the first character
if it exists, and if it does, check to see if it is in the category. Notice that 
we introduced two new <code>ParseError</code>s.</p>
<pre><code>#[derive(Debug, PartialEq)]
pub enum ParseError {
    GenericError,
    ExpectingCharacter(char),
    ExpectingPredicate,
    EndOfInput,
}
</code></pre>
<h1><a class="header" href="#constructor-and-factory" id="constructor-and-factory">Constructor and Factory</a></h1>
<p>The final two steps are to create a constructor and a convenient factory.</p>
<pre><code>impl&lt;F&gt; Any&lt;F&gt; where F: Fn(char) -&gt; bool + Sized {
    pub fn new(predicate: F) -&gt; Self {
        Any { predicate }
    }
}

pub fn any&lt;'a, F&gt;(predicate: F) -&gt; impl Parser&lt;'a, char&gt; where F: Fn(char) -&gt; bool + Sized {
    Any::new(predicate)
}
</code></pre>
<h2><a class="header" href="#summary-1" id="summary-1">Summary</a></h2>
<p>Just like the first parser we made, we followed a predictable course.</p>
<ol>
<li>Choose a datatype that allows the parser to do it's job.</li>
<li>Implement <code>Parser</code> for it.</li>
<li>Create a <em>constructor</em>.</li>
<li>Create a factory.</li>
</ol>
<p>This pattern will be repeated many times.</p>
<h2><a class="header" href="#exercises-4" id="exercises-4">Exercises</a></h2>
<ol>
<li>Implement the <code>Any</code> parser.</li>
<li>Write some tests to check your implementation.</li>
</ol>
<h1><a class="header" href="#interpreter-1" id="interpreter-1">Interpreter</a></h1>
<p>In the Parser section we created a parser for <code>.ls</code> files that could return a
L-system data structure. We would now like to interpret this data structure in
order to evolve the L-system a number of iterations.</p>
<p>The Interpreter section will guide use along that path and describes how to
create software that can interpret our L-system and evolve the start word.</p>
<p>Make sure to look in to <a href="dependencies.html">working with dependencies</a> to find out
how to incorporate your code into the project.</p>
<h1><a class="header" href="#what-is-an-interpreter" id="what-is-an-interpreter">What is an Interpreter</a></h1>
<h1><a class="header" href="#renderer-1" id="renderer-1">Renderer</a></h1>
<p>With a working parser and interpreter for L-systems, it is time to work on
rendering. Rendering concerns itself providing a translation between the 
L-systems words that occur from the start word and some kind of visualization.</p>
<p>Make sure to look in to <a href="dependencies.html">working with dependencies</a> to find out
how to incorporate your code into the project.</p>
<h1><a class="header" href="#what-is-a-renderer" id="what-is-a-renderer">What is a Renderer</a></h1>
<h1><a class="header" href="#working-with-dependencies" id="working-with-dependencies">Working with Dependencies</a></h1>
<p>There are two different goals for this workshop. First is to allow you to play
with L-systems. Second is to allow you to code your own L-system, and then play
with that.</p>
<p>In order to facilitate that the code makes use of path dependencies. That way we
use can easily transition from relying on provided code to relying on your own
code.</p>
<h2><a class="header" href="#mechanism" id="mechanism">Mechanism</a></h2>
<p>If you take a look at the <code>Cargo.toml</code> file you will notice the <code>[dependencies]</code>
table has a lot of path dependencies. E.g. we have a dependency on <code>parser</code>
which can be found at <code>examplar-parser</code>, according to the following snippet.</p>
<pre><code class="language-toml">[dependencies]
parser = { path = &quot;examplar-parser&quot; }
</code></pre>
<h3><a class="header" href="#your-code" id="your-code">Your code</a></h3>
<p>Every <code>examplar-*</code> library has a regular counter-part. I.e. besides
<code>examplar-parser</code> there is also <code>parser</code> library. This library has some skeletal
code. It is an ideal starting ground for working on your own code.</p>
<h3><a class="header" href="#hooking-up-your-code" id="hooking-up-your-code">Hooking up your code</a></h3>
<p>Once you are comfortable with your code, it is time to hook it up to the main
executable. This way you can play with your own L-system.</p>
<p>This is done by changing the top-level <code>Cargo.toml</code>. Specifically the
<code>[dependencies]</code> table. For the <code>[dependencies]</code> you need to point to the correct
path. E.g. for the parser dependency the path should be <code>parser</code> if you want to
use your own code. </p>
<h3><a class="header" href="#enjoy-your-l-system" id="enjoy-your-l-system">Enjoy your L-System</a></h3>
<p>If everything works out, you should be able to enjoy your own L-system
framework.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
