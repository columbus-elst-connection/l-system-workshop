<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>L-Systems</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A compendium to the L-Systems workshop">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="outline.html"><strong aria-hidden="true">2.</strong> Outline</a></li><li><a href="l-system.html"><strong aria-hidden="true">3.</strong> L-system</a></li><li><ol class="section"><li><a href="lsystem/Aristid.html"><strong aria-hidden="true">3.1.</strong> Aristid Lindenmayer</a></li><li><a href="lsystem/algae.html"><strong aria-hidden="true">3.2.</strong> Algae</a></li></ol></li><li><a href="parser.html"><strong aria-hidden="true">4.</strong> Parsers</a></li><li><ol class="section"><li><a href="parser/what.html"><strong aria-hidden="true">4.1.</strong> What is a Parser?</a></li><li><a href="parser/type.html"><strong aria-hidden="true">4.2.</strong> Looking at the type</a></li><li><a href="parser/function.html"><strong aria-hidden="true">4.3.</strong> Functions are Parsers!</a></li><li><a href="parser/character.html"><strong aria-hidden="true">4.4.</strong> Parsing a char</a></li><li><a href="parser/any.html"><strong aria-hidden="true">4.5.</strong> Parsing any char</a></li><li><a href="parser/literal.html"><strong aria-hidden="true">4.6.</strong> Literal</a></li><li><a href="parser/combinators.html"><strong aria-hidden="true">4.7.</strong> Combinators</a></li><li><a href="parser/map.html"><strong aria-hidden="true">4.8.</strong> Map</a></li><li><a href="parser/between.html"><strong aria-hidden="true">4.9.</strong> Between</a></li><li><a href="parser/oneof.html"><strong aria-hidden="true">4.10.</strong> OneOf</a></li><li><a href="parser/utilities.html"><strong aria-hidden="true">4.11.</strong> Utilities</a></li><li><a href="parser/macros.html"><strong aria-hidden="true">4.12.</strong> Macros</a></li><li><a href="parser/sequence.html"><strong aria-hidden="true">4.13.</strong> Parsing a sequence</a></li><li><a href="parser/framework.html"><strong aria-hidden="true">4.14.</strong> Use the framework</a></li></ol></li><li><a href="interpreter.html"><strong aria-hidden="true">5.</strong> Interpreter</a></li><li><ol class="section"><li><a href="interpreter/what.html"><strong aria-hidden="true">5.1.</strong> What is an Interpreter</a></li></ol></li><li><a href="renderer.html"><strong aria-hidden="true">6.</strong> Renderer</a></li><li><ol class="section"><li><a href="renderer/what.html"><strong aria-hidden="true">6.1.</strong> What is a Renderer</a></li></ol></li><li><a href="extensions.html"><strong aria-hidden="true">7.</strong> Why stop here</a></li><li class="affix"><a href="dependencies.html">Working with Dependencies</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">L-Systems</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>This book is a compendium to the <a href="https://en.wikipedia.org/wiki/L-system">L-systems</a> workshop.</p>
<p>This book and the workshop will introduce you to L-systems, allowing you to play
and understand them.</p>
<p>Understanding means that you get the opportunity to create a program that reads,
evaluates and renders an L-system. We will start from scratch and teach you all
the necessary tools and techniques to finish.</p>
<p>This book serves as a guide during your journey. A trusty companion that cheers
you on, helps you when you are stuck and can turn to when your motivation is
low.</p>
<h2><a class="header" href="#not-at-a-workshop" id="not-at-a-workshop">Not at a workshop?</a></h2>
<p>This book is written to be self contained. The only downside of not being in a
workshop is missing the ability to ask questions and getting a quick answer.</p>
<p>There still is the ability to ask questions, it might just take some time before
we can answer them. Try one of the following means of communication</p>
<ul>
<li><a href="https://join.slack.com/t/col-els-con/shared_invite/enQtNjUzNTYyNDY2ODIxLTRjZTBkMzlkNzMyNjMwNzg0Njg3MzhlZDQ3ZjE0OWI2OGFhMWYyNDhiZTVmZTFiMzI5NmZhOWQ2ZWIxZjUwZTQ">Slack</a></li>
<li><a href="https://github.com/columbus-elst-connection/workshop/issues">GitHub Issues</a></li>
<li><a href="mailto://daan.v.berkel.1980+l-system@gmail.com">Mail</a></li>
</ul>
<h1><a class="header" href="#outline" id="outline">Outline</a></h1>
<p>There are various ways of learning and we want to enable you to choose your path
through the material. Below you can find the main sections that we will address
during this workshop.</p>
<p>It is possible to progress through the sections in any order you want. We have
setup things in such a way that you can rely on our code so long as yours is not
ready.</p>
<h2><a class="header" href="#l-systems" id="l-systems">L-systems</a></h2>
<p>This section teaches you what <a href="https://en.wikipedia.org/wiki/L-system">L-systems</a> are, trains you how to
create them, and allows you to play with them.</p>
<p>Describing a L-system is one thing. Teaching a computer how to work with
L-systems is another. The next sections are major parts in the software that
allows you to explore L-systems.</p>
<h2><a class="header" href="#parser" id="parser">Parser</a></h2>
<p>A <a href="https://en.wikipedia.org/wiki/Parsing">parser</a> is a</p>
<blockquote>
<p>software component that takes input data (frequently text) and builds a data
structure – often some kind of parse tree, abstract syntax tree or other
hierarchical structure, giving a structural representation of the input while
checking for correct syntax. </p>
</blockquote>
<p>This section focuses on parsing a L-system. We do this by creating our own
<a href="https://en.wikipedia.org/wiki/Parser_combinator">Parser Combinator framework</a> that we use to read an L-system
and turn it into a data structure that we can use.</p>
<h2><a class="header" href="#interpreter" id="interpreter">Interpreter</a></h2>
<p>Once you have defined an L-system, you probably would like to do something with
it. The <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreter</a> helps with this goal. It diligently executes the
instructions described by the L-system informing interested parties what has
happened.</p>
<p>The interpreter is the workhorse of our program. Although it is the centerpiece
of our software, it is a quit simple machine.</p>
<h2><a class="header" href="#renderer" id="renderer">Renderer</a></h2>
<p>An L-system without a &quot;picture&quot; is as a Christmas tree without decorations. It
still is instructive, but is sure isn't as much fun.</p>
<p>In this section we explore various way of make a &quot;picture&quot; for our L-system.
There are various ways of turning the L-system into meaningful artifact. Making
an image is surely not the only one.</p>
<h1><a class="header" href="#l-system" id="l-system">L-system</a></h1>
<p>This section teaches you all about what <a href="https://en.wikipedia.org/wiki/L-system">L-systems</a> are.</p>
<p>Read about Aristid Lindenmayer and why he invented his system. Explore the rich
language and it's beautiful images.</p>
<h1><a class="header" href="#aristid-lindenmayer" id="aristid-lindenmayer">Aristid Lindenmayer</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Aristid_Lindenmayer">Aristid Lindenmayer</a> was a Hungarian biologist. He lived from 1925
until 1989. He studied biology and chemistry at the university of Budapest.
Lindenmayer got his Ph.D. from the University of Michigan before accepting a
position as professor in Philosophy of Life Sciences and Biology at the
University of Utrecht.</p>
<p><img src="lsystem//image/lindenmayer.jpg" alt="Aristid Lindenmayer" /></p>
<h1><a class="header" href="#algae" id="algae">Algae</a></h1>
<p>Aristid Lindenmayer introduces a system of substitutions that would later bear his name. He did this in a set of two articles; <em>Mathematical Models for Cellular Interactions in Development</em>. As the title implies it offers a mathematical theory to model growth in certain type of cells. Stripping away the mathematics his article described an example that modeled algae. A more modern description follows below.</p>
<p>We will study <em>words</em>, i.e. a sequence of symbols, over an <em>alphabet</em>. In our example we take our alphabet to be the symbols <em>A</em>, and <em>B</em>. We will examine a series of words. In the algae example we are starting with the word <em>A</em>. 
With the current word in the series, we replace each symbol with a sequence of symbols and concatenating the sub-sequences in a new word. In our example we will replace each occurring symbol <em>A</em> with the sequence <em>AB</em>, and each occurring symbol <em>B</em> with the sequence <em>A</em>.</p>
<p>Below you find the first few iterations of this process.</p>
<ol>
<li><em>A</em>, our starting word.</li>
<li><em>AB</em>, because the single <em>A</em> is replaced with <em>AB</em>.</li>
<li><em>ABA</em>, because the single <em>A</em> is replaced with <em>AB</em> and the <em>B</em> is replaced with <em>A</em>.</li>
<li><em>ABAAB</em>, because each <em>A</em> is replaced with <em>AB</em> and each <em>B</em> is replaced with <em>A</em>.</li>
</ol>
<p>In the above model the symbol <em>A</em> is a model for a mature cell, ready to divide itself. The division however is asymmetric. It allows the original cell to comfortable remain in place, making place for a young cell <em>B</em>. In its stead, the young cell <em>B</em> first must mature to and become an <em>A</em> cell before it can start reproducing itself.</p>
<p>Although this is a simple model. A lot can be learned from this. For an few examples, see the exercises.</p>
<h2><a class="header" href="#exercises" id="exercises">Exercises</a></h2>
<ol>
<li>Extend the example with the a few iterations.</li>
<li>Count the number of symbols in each word of the series. Guess what number comes next.</li>
<li>Count the number of <em>A</em>'s and the number of <em>B</em>'s separately. What do you get.</li>
<li>We will number the words in our series, \(W_{0}\) for our start word, \(W_{1}\), for the next, \(W_{2}\) for the one after that, etcetera. Pick any number, let's say 4. Notice how \(W_{4}\), i.e. <em>ABAAB</em> is the concatenation of <em>ABA</em>, which is \(W_{3}\), and <em>AB</em>, which is \(W_{2}\). In other words \(W_{4}=W_{3}W_{2}\).</li>
</ol>
<ul>
<li>Check if something similar holds for \(W_{3}\) and \(W_{5}\).</li>
<li>Does this property, i.e. \(W_{k} = W_{k-1}W_{k-2}\) always hold?</li>
</ul>
<h1><a class="header" href="#parser-1" id="parser-1">Parser</a></h1>
<p>In the L-system section you have had the opportunity to learn about and play with
Lindenmayer systems. The Parser section starts our journey of creating our own
software to explore L-systems.</p>
<p>The journey starts with teaching the computer about <code>.ls</code> files and what we
describe with them. </p>
<p>Make sure to look in to <a href="dependencies.html">working with dependencies</a> to find out
how to incorporate your code into the project.</p>
<h1><a class="header" href="#what-is-a-parser" id="what-is-a-parser">What is a Parser?</a></h1>
<p>A <a href="https://en.wikipedia.org/wiki/Parsing">parser</a> is a</p>
<blockquote>
<p>software component that takes input data (frequently text) and builds a data
structure – often some kind of parse tree, abstract syntax tree or other
hierarchical structure, giving a structural representation of the input while
checking for correct syntax.</p>
</blockquote>
<p>In our case we want to teach the computer to understand <code>.ls</code> files. This is our
<em>input data</em>. Although this input is convenient for us, it is just a sequences of
bytes to a computer.</p>
<p>What we want is an L-system that we can manipulate. That is our <em>data
structure</em>. Parsing is what brings us from our input data to our L-system.</p>
<h2><a class="header" href="#parser-framework" id="parser-framework">Parser framework</a></h2>
<p>We will be building our own Parser framework. I.e. we will build the
infrastructure that allows us to create a custom parser. We will use our
framework to create a specific parser that reads in our <code>.ls</code> files and create
the L-system for us.</p>
<h2><a class="header" href="#parser-combinator" id="parser-combinator">Parser Combinator</a></h2>
<p>Our framework will be based on the concept of Parser Combinators. A Parser
Combinator is a</p>
<blockquote>
<p>higher-order function that accepts several parsers as input and returns a new
parser as its output. In this context, a parser is a function accepting strings
as input and returning some structure as output, typically a parse tree or a set
of indices representing locations in the string where parsing stopped
successfully.</p>
</blockquote>
<p>If this does not really makes sense to you. Keep reading and soon you will be an
expert Parser Combinatorist.</p>
<h1><a class="header" href="#looking-at-the-type" id="looking-at-the-type">Looking at the type</a></h1>
<p>Before we start out it is good to think what we want to achieve. This allows us
to reason about the constraints and capture those in our types.</p>
<p>A parser reads input and transforms that into some data structure. This already
provides us with a decision. I.e. what type is our input?</p>
<p>We want to make things easy for our selves and since string literals have type
<code>&amp;str</code> we our going to pick that as our input type.</p>
<p>We don't really know what output type is going to be, put we do know that the
parser could fail. Take a look at the following code</p>
<pre><code class="language-lsystem">F -&gt; FF
</code></pre>
<p>Although it looks like an L-system, it not quite an L-system. At least not in
the form we expect in the L-system section. The arrow is wrong!</p>
<p>Because the data-structure could be anything, we better make it a generic
parameter. So our first guess for the output type could be
<code>Result&lt;T, ParserError&gt;</code>, where <code>ParserError</code> is defined as</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, PartialEq)]
pub enum ParseError {
    GenericError,
}
#}</code></pre></pre>
<h2><a class="header" href="#combinator" id="combinator">Combinator</a></h2>
<p>Although our first guess isn't that far off, it is lacking some flexibility.
What we like to achieve is to easily combine different kind of parsers into a
more complex one.</p>
<p>With this goal in mind, we would like to pass information about what part of the
input still needs parsing. Because we want to feed that into a different parser,
that type should be <code>&amp;str</code>, our input type.</p>
<p>So our second guess is <code>Result&lt;(T, &amp;str), ParseError&gt;</code>.</p>
<p>A Parser returns either a tuple of the parsed result and the rest of the
input, or it returns an error. </p>
<h2><a class="header" href="#trait" id="trait">Trait</a></h2>
<p>We now can create a <code>trait</code> that describes the contract our parsers have. It is
little more than our consideration, with the correct use of lifetimes to keep
the compiler happy.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Parser&lt;'a, T&gt; {
    fn parse(&amp;self, input: &amp;'a str) -&gt; Result&lt;(T, &amp;'a str), ParseError&gt;;
}
#}</code></pre></pre>
<p>So a Parser is anything that has a <code>parse</code> method of the right signature.</p>
<h2><a class="header" href="#exercises-1" id="exercises-1">Exercises</a></h2>
<ol>
<li>Implement the <code>Parser</code> trait and the <code>ParseError</code> enum in <code>src/framework.rs</code>.</li>
</ol>
<h1><a class="header" href="#functions-are-parsers" id="functions-are-parsers">Functions are Parsers!</a></h1>
<p>With our <code>Parser</code> trait in place we can start implementing it. Thinking about
the trait one implementation springs to mind.</p>
<p>If we have a function, or a lambda expression for that matter, that has the
right signature. I.e. accepts a <code>&amp;str</code> and returns a 
<code>Result&lt;(T, &amp;str), ParseError&gt;</code>, in some sense it is a parser. We just have to
apply the function! </p>
<p>Let's start with that implementation.</p>
<pre><code>impl &lt;'a, T, F&gt; Parser&lt;'a, T&gt; for F where F: Fn(&amp;'a str) -&gt; Result&lt;(T, &amp;'a str), ParseError&gt; {
    fn parse(&amp;self, input: &amp;'a str) -&gt; Result&lt;(T, &amp;'a str), ParseError&gt; {
        self(input)
    }
}
</code></pre>
<h2><a class="header" href="#exercises-2" id="exercises-2">Exercises</a></h2>
<ol>
<li>Write the implementation of the <code>Parser</code> trait for <code>Fn(&amp;'a str) -&gt; Result&lt;(T, &amp;'a str), ParserError&gt;</code>.</li>
</ol>
<h1><a class="header" href="#parsing-a-char" id="parsing-a-char">Parsing a <code>char</code></a></h1>
<p>In this chapter we will spend some time explaining how to create a <code>Parser</code>
capable of parsing a <code>char</code>. We will go through all the motions and explain
all the steps.</p>
<p>Our goal for this chapter is to make the following test pass.</p>
<pre><code>    #[test]
    fn parse_a_character() {
        let input = &quot;ABCD&quot;;
        let parser = character('A');

        let actual = parser.parse(input);

        let expected = Ok(('A', &quot;BCD&quot;));
        assert_eq!(actual, expected);
    }
</code></pre>
<p>So let's get started.</p>
<h2><a class="header" href="#character" id="character">Character</a></h2>
<p>Thinking about the challenge of parsing a <code>char</code> one could notice the following
things. Giving a certain <code>&amp;str</code>, we need to</p>
<ol>
<li>Check if it starts with the correct character.</li>
<li>If it does, return it and the rest of the <code>&amp;str</code>.</li>
<li>If it does not, report an error.</li>
</ol>
<p>In order to be able to implement the <code>Parser</code> trait, there first needs to be
something we can implement the <code>Parser</code> trait for. This thing will need to keep
track of what character to parse.</p>
<p>We will use a struct <code>Character</code> for that. We will give it a field that tracks
the intended character to match.</p>
<pre><code>pub struct Character {
  character_to_match: char,
}
</code></pre>
<h2><a class="header" href="#impl-parser" id="impl-parser">Impl Parser</a></h2>
<p>Let's implement <code>Parser</code> for the <code>Character</code> struct. We will be guided by the outline above</p>
<pre><code>impl&lt;'a&gt; Parser&lt;'a, char&gt; for Character {
    fn parse(&amp;self, input: &amp;'a str) -&gt; Result&lt;(char, &amp;'a str), ParseError&gt; {
        if input.starts_with(self.character_to_match) {
            Ok((self.character_to_match, &amp;input[1..]))
        } else {
            Err(ParseError::ExpectingCharacter(self.character_to_match))
        }
    }
}
</code></pre>
<p>The first two lines are the signature needed to adhere to the traits contract.
Next we check if the input starts with the character to match. If it does, we
return a succesful parse with the matched character and the remaining input.
Otherwise we announce an error, which we also need to add to our <code>ParseError</code>
enum.</p>
<pre><code>#[derive(Debug, PartialEq)]
pub enum ParseError {
    GenericError,
    ExpectingCharacter(char),
}
</code></pre>
<h2><a class="header" href="#constructor" id="constructor">Constructor</a></h2>
<p>It is convenient to create a <em>constructor</em> for our <code>Character</code> struct. This eases the
burden of creating a <code>Character</code> parser.</p>
<pre><code>impl Character {
    pub fn new&lt;'a&gt;(character_to_match: char) -&gt; impl Parser&lt;'a, char&gt; {
        Self { character_to_match }
    }
}
</code></pre>
<p>Notice the return type of our constructor. It hides the implementation details.
It only tells you that you can expect to get something that implements a <code>Parser</code>
that returns a <code>char</code> on success.</p>
<p>This allows us greater flexibility in the future. We can easily change the structure
of Character without changing the constructor, or code that relies on it.</p>
<h2><a class="header" href="#factory" id="factory">Factory</a></h2>
<p>An other convience is the use of a <a href="https://en.wikipedia.org/wiki/Factory_method_pattern">factory</a>. A factory is a pattern that hides the
details of how an struct is created. It serves yet an other purpose, to use a name that
reflects the intention, instead of exposing the mechanism of construction.</p>
<p>So instead of writing <code>Character::new('a')</code>, we want to write <code>character('a')</code>. Under
the covers this is done by using the constructor for <code>Character</code>.</p>
<pre><code>pub fn character&lt;'a&gt;(character_to_match: char) -&gt; impl Parser&lt;'a, char&gt; {
    Character::new(character_to_match)
}
</code></pre>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>Since the <code>Character</code> parser is an example of how parser can be created we are going to
summarize the steps.</p>
<ol>
<li>Choose a datatype that allows the parser to do it's job.</li>
<li>Implement <code>Parser</code> for it.</li>
<li>Create a <em>constructor</em>.</li>
<li>Create a factory.</li>
</ol>
<p>The <code>Character</code> parse was build of a struct. Implementing <code>Parser</code> was done by translating
the parsing process into rust. And constructor and factory were created for ease of use.</p>
<h2><a class="header" href="#exercises-3" id="exercises-3">Exercises</a></h2>
<ol>
<li>Implement the <code>Character</code> parser.</li>
<li>Write some tests to check your implementation.</li>
</ol>
<h1><a class="header" href="#parsing-any-char" id="parsing-any-char">Parsing any <code>char</code></a></h1>
<p>In a previous chapter we created a parser that could parse a single
specific character. An other useful parser would parse a string
would start with any of a group of characters.</p>
<p>To be more precise. Let's say that we would like to parse a <code>&amp;str</code> if
it starts with a digit. What we would like to achieve is to pass the 
following test</p>
<pre><code>    #[test]
    fn parse_any_digit() {
        let input = &quot;0123&quot;;
        let parser = any(|c: char| c.is_ascii_digit());

        let actual = parser.parse(input);

        let expected = Ok(('0', &quot;123&quot;));
        assert_eq!(actual, expected);
    }
</code></pre>
<p>We will go through all the motions of creating a parser once more.</p>
<h2><a class="header" href="#any" id="any">Any</a></h2>
<p>We will create a struct that will contain everything it needs to
make our wish come through. For this we need to be able to store
a <em>predicate</em>, a function that will decide on the characters we
expect.</p>
<pre><code>pub struct Any&lt;F&gt; where F: Fn(char) -&gt; bool + Sized {
    predicate: F,
}
</code></pre>
<p>Here <code>F</code> is an alias for the <code>Fn(char) -&gt; bool + Sized</code> type.
Our predicate, is a function that accepts a character and tells
use if it does or does not fall in our category. The <code>Sized</code> restriction
is necessary because we want to store it in our field.</p>
<h2><a class="header" href="#impl-parser-1" id="impl-parser-1">Impl Parser</a></h2>
<p>Next we our going to implement the <code>Parser</code> trait. The basic idea is,
given our input</p>
<ol>
<li>Check if it starts with a character from our category.</li>
<li>If it does, return it and the rest of the input.</li>
<li>If it does not, return an error.</li>
</ol>
<p>The difference with the <code>Character</code> parser is that <code>String</code> does not have
a convenience method like <code>starts_with</code> that we can use. Instead we can use
an <em>iterator</em> over the characters of our input. See below for details.</p>
<pre><code>impl&lt;'a, F&gt; Parser&lt;'a, char&gt; for Any&lt;F&gt; where F: Fn(char) -&gt; bool + Sized {
    fn parse(&amp;self, input: &amp;'a str) -&gt; Result&lt;(char, &amp;'a str), ParseError&gt; {
        let character = input.chars().next();
        match character {
            Some(c) =&gt; {
                if (self.predicate)(c) {
                    Ok((c, &amp;input[1..]))
                } else {
                    Err(ParseError::ExpectingPredicate)
                }
            },

            None =&gt; {
                Err(ParseError::EndOfInput)
            }
        }
    }
}
</code></pre>
<p>We ask our input for an iterator over its characters. Match on the first character
if it exists, and if it does, check to see if it is in the category. Notice that 
we introduced two new <code>ParseError</code>s.</p>
<pre><code>#[derive(Debug, PartialEq)]
pub enum ParseError {
    GenericError,
    ExpectingCharacter(char),
    ExpectingPredicate,
    EndOfInput,
}
</code></pre>
<h1><a class="header" href="#constructor-and-factory" id="constructor-and-factory">Constructor and Factory</a></h1>
<p>The final two steps are to create a constructor and a convenient factory.</p>
<pre><code>impl&lt;F&gt; Any&lt;F&gt; where F: Fn(char) -&gt; bool + Sized {
    pub fn new(predicate: F) -&gt; Self {
        Self { predicate }
    }
}

pub fn any&lt;'a, F&gt;(predicate: F) -&gt; impl Parser&lt;'a, char&gt; where F: Fn(char) -&gt; bool + Sized {
    Any::new(predicate)
}
</code></pre>
<h2><a class="header" href="#summary-1" id="summary-1">Summary</a></h2>
<p>Just like the first parser we made, we followed a predictable course.</p>
<ol>
<li>Choose a datatype that allows the parser to do it's job.</li>
<li>Implement <code>Parser</code> for it.</li>
<li>Create a <em>constructor</em>.</li>
<li>Create a factory.</li>
</ol>
<p>This pattern will be repeated many times.</p>
<h2><a class="header" href="#exercises-4" id="exercises-4">Exercises</a></h2>
<ol>
<li>Implement the <code>Any</code> parser.</li>
<li>Write some tests to check your implementation.</li>
</ol>
<h1><a class="header" href="#parsing-a-literal-string" id="parsing-a-literal-string">Parsing a Literal String</a></h1>
<p>Often you know exactly what you are looking for. E.g. when separating the the
symbol for its production we use <code>=&gt;</code>. I would come in handy if there was a
parser that could do that job.</p>
<pre><code>    #[test]
    fn parse_literal_arrow() {
        let input = &quot;=&gt; FF&quot;;
        let parser = literal(&quot;=&gt;&quot;);

        let actual = parser.parse(input);

        let expected = Ok((&quot;=&gt;&quot;, &quot; FF&quot;));
        assert_eq!(actual, expected);
    }
</code></pre>
<h2><a class="header" href="#literal" id="literal">Literal</a></h2>
<p>The only thing that we need to keep track of is the string that we are
interested in. Rust provides various ways to model your data. <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">Tuple
structs</a>
are a convenient way for our use case. It allows one to name a structure by
describing the fields in a tuple.</p>
<pre><code>pub struct Literal&lt;'p&gt;(&amp;'p str);
</code></pre>
<p>Note that we have a tuple with only one field. It does not have a name so we
need to reference it by index.</p>
<h2><a class="header" href="#impl-parser-2" id="impl-parser-2">Impl Parser</a></h2>
<p>Parsing with a <code>Literal</code> amounts to the following steps</p>
<ol>
<li>Check if the input starts with our literal.</li>
<li>If it does, chop of the parsed string and return it together with the
remaining input</li>
<li>If it does not, report an error.</li>
</ol>
<p>This translate into code as follows.</p>
<pre><code>impl &lt;'a, 'p&gt; Parser&lt;'a, &amp;'a str&gt; for Literal&lt;'p&gt; {
    fn parse(&amp;self, input: &amp;'a str) -&gt; Result&lt;(&amp;'a str, &amp;'a str), ParseError&gt; {
        if input.starts_with(self.0) {
            let len = self.0.len();
            let substr = &amp;input[..len];
            let rem = &amp;input[len..];
            Ok((substr, rem))
        } else {
            Err(ParseError::ExpectingLiteral(self.0.to_owned()))
        }
    }
}
</code></pre>
<p>Take a look at the expected result. It has type <code>&amp;'a str</code>. We will return a
slice of the input, so the lifetime should match up.</p>
<h2><a class="header" href="#constructor-1" id="constructor-1">Constructor</a></h2>
<p>Since tuple structs come with a build int constructor, we do not need to do
anything here.</p>
<h2><a class="header" href="#factory-1" id="factory-1">Factory</a></h2>
<p>The factory for the <code>Literal</code> parser can just be a function <code>literal</code> to returns
the parser</p>
<pre><code>pub fn literal(match_exactly: &amp;str) -&gt; Literal {
    Literal(match_exactly)
}
</code></pre>
<h2><a class="header" href="#exercises-5" id="exercises-5">Exercises</a></h2>
<ol>
<li>Implement the <code>Literal</code> parser.</li>
<li>Create some tests to verify your implementation.</li>
</ol>
<h1><a class="header" href="#combinators" id="combinators">Combinators</a></h1>
<p>We havee implemented a few parser. Each followed the same pattern.</p>
<ol>
<li>Choose a datatype that allows the parser to do it's job.</li>
<li>Implement <code>Parser</code> for it.</li>
<li>Create a <em>constructor</em>.</li>
<li>Create a factory.</li>
</ol>
<p>This pattern suffices, but it get's tedious. Instead we would rather
use the power of <em>abstraction</em>. Rather than to depend on the manual
work to create a parser for each situation, we want to have some 
primitive parser that we can combine into a more elaborate parser.</p>
<p>This chapter introduces you to the concept and some considerations
we will meet along the way.</p>
<h2><a class="header" href="#what-is-a-combinator" id="what-is-a-combinator">What is a combinator</a></h2>
<p>In our case a combinator is a <em>higher order</em> parser. It takes one or
more parsers and <em>combines</em> them into a new parser.</p>
<p>Let's stare into the future together, in order to better understand
combinators.</p>
<p>Imagine that we have a parser that could parse a single rule of a 
L-system. How we acquired this parser is of no concern. Just that
we can use it.</p>
<p>Now as you know, L-systems often have many rules. So we would like
a parser that could parse many rules. We could use the rule parser
and manually try to parse a rule, and when it succeed try for the
next rule.</p>
<p>This would certainly work! But it would not help in the situation
where we have a parser to parse a single whitespace and would want
a parser to parse a many whitespaces. This is a very similar 
situation to the rule parser, the only difference being the kind
of parser you want many of.</p>
<p>Instead we are going to write a <em>combinator</em>. This is a parser that
accepts as an argument one or more parsers, in our example the rule
parser or the whitespace parser, and returns a parser that combines
them in an interesting way. In our example that would be the many
combinator.</p>
<h2><a class="header" href="#combinator-pattern" id="combinator-pattern">Combinator Pattern</a></h2>
<p>What we have described for parser is an example of a more general
pattern. I.e. the <a href="https://wiki.haskell.org/Combinator_pattern">combinator pattern</a>. It says</p>
<blockquote>
<p>complex structures are built by defining a small set of very simple 
'primitives', and a set of 'combinators' for combining them into 
more complicated structures. </p>
</blockquote>
<p>If you squint hard you can find our explanation of the phenomenon
for parser in the description.</p>
<p>So the next few chapters will concentrate on the description of
various combinators.</p>
<h1><a class="header" href="#map" id="map">Map</a></h1>
<p>The first combinator we are going describe is the <code>Map</code> combinator.
Let's say we have a parser to parse a digit, i.e.
<code>any(|c: char| c.is_ascii_digit())</code>. But we are not interested in the
character, but in the integer.</p>
<p><code>char</code> has a method that can return the numeric value of a digit
character. It has the following signature. </p>
<pre><code>pub fn to_digit(self, radix: u32) -&gt; Option&lt;u32&gt;
</code></pre>
<p>Notice that the return type is an <code>Option</code>, because if all you have is
a character, you are not sure how to turn it into a number. E.g. What
is the value of <code>Y</code>?</p>
<p>So the code we would like to run is something along the lines of</p>
<pre><code>    #[test]
    fn parse_any_digit_as_number() {
        let input = &quot;1230&quot;;
        let parser = map(
          any(|c: char| c.is_ascii_digit()), 
          |c: char| c.to_digit(10).unwrap_or(0));

        let actual = parser.parse(input);

        let expected = Ok((1, &quot;230&quot;));
        assert_eq!(actual, expected);
    }
</code></pre>
<p>During the mapping we are unwrapping the option with a default value of
zero.</p>
<h2><a class="header" href="#map-1" id="map-1">Map</a></h2>
<p>With our goal clear, we still are following our strategy. So, let's first
create a struct.</p>
<pre><code>pub struct Map&lt;'a, I, O, P, F&gt; where I: 'a, P: Parser&lt;'a, I&gt; + Sized, F: Fn(I) -&gt; O + Sized {
    parser: P,
    map: F,
}
</code></pre>
<p>Woah, that signature has a lot of stuff in it. Let's break it done step by step.</p>
<h3><a class="header" href="#lifetimes--generics" id="lifetimes--generics">Lifetimes &amp; Generics</a></h3>
<p>First of all there is a lifetime ``a<code>parameter. This lifetime is needed by</code>Parser` and keeps track of the lifetime of the input.</p>
<p>Next are generic parameters <code>I</code> and <code>O</code>. They are used by the other generic
parameters <code>P</code> and <code>F</code>.  Almost all of these are aliases.</p>
<p><code>I</code> is restricted to <code>I: 'a</code>. It should live as long as our input. Together
with the chosen letter <code>I</code>, it probably stands for some form of input.</p>
<p><code>P</code> is restricted to <code>P: Parser&lt;'a, I&gt; + Sized</code>. So <code>P</code> is a parser that
produces an <code>I</code>. For example our <code>any</code> parser is a produces an <code>char</code>.</p>
<p><code>F</code> is restricted to <code>F: Fn(I) -&gt; O + Sized</code>. Now it becomes clear would
<code>I</code> and <code>O</code> are. They are the input and output for the function <code>F</code>. So
<code>F</code> is a function that is used to map the result of parser <code>P</code>, which is
of type <code>I</code>, into type <code>O</code>.</p>
<p>Pfew, that was a lot to take in. But with an overview all the parts make
sense.</p>
<h3><a class="header" href="#phantomdata" id="phantomdata"><code>PhantomData</code></a></h3>
<p>Unfortunatly, this will not compile. The compiler warns us of several
unused parameters. E.g.</p>
<pre><code class="language-plain">82 | pub struct Map&lt;'a, I, O, P, F&gt; where I: 'a, P: Parser&lt;'a, I&gt; + Sized, F: Fn(I) -&gt; O + Sized {
   |                ^^ unused parameter
   |
   = help: consider removing `'a` or using a marker such as `std::marker::PhantomData`
</code></pre>
<p>The advice of removing the lifetime parameter is not an option for us.
We need it for our parser <code>P</code>. Maybe the other advice is viable.</p>
<p>The doccumentation of <code>PhantomData</code> reads</p>
<blockquote>
<p>Zero-sized type used to mark things that &quot;act like&quot; they own a T.</p>
<p>Adding a PhantomData<T> field to your type tells the compiler that 
your type acts as though it stores a value of type T, even though
it doesn't really. This information is used when computing certain 
safety properties.</p>
</blockquote>
<p>That is precisely our case. What a good compiler our compiler is. So
we will follow our compilers advice and add a phantom field to our
struct.</p>
<pre><code>    phantom: PhantomData&lt;&amp;'a I&gt;,
</code></pre>
<p>Which satisfies the compiler.</p>
<h2><a class="header" href="#impl-parser-3" id="impl-parser-3">Impl Parser</a></h2>
<p>With our struct out of the way, we should focus on the implementation.
What we want to achieve is</p>
<ol>
<li>Try the parser.</li>
<li>Map the result with our function, keeping the rest of our input.</li>
</ol>
<p>Besides the verbose type signatures this translates very well into Rust.</p>
<pre><code>impl&lt;'a, I, O, P, F&gt; Parser&lt;'a, O&gt; for Map&lt;'a, I, O, P, F&gt; where I: 'a, P: Parser&lt;'a, I&gt; + Sized, F: Fn(I) -&gt; O + Sized {
    fn parse(&amp;self, input: &amp;'a str) -&gt; Result&lt;(O, &amp;'a str), ParseError&gt; {
        let attempt = self.parser.parse(input);
        attempt.map(|(v, rest)|{ ((self.map)(v), rest)})
    }
}
</code></pre>
<h2><a class="header" href="#constructor--factory" id="constructor--factory">Constructor &amp; Factory</a></h2>
<p>Creating the constructor and factory is almost straight forward, albeit
verbose. Accept the parameters you need and create the <code>Map</code>. The only
snag is that <code>PhantomData</code>.</p>
<p>Luckily the way to assign a <code>PhantomData</code> is by doing just that.</p>
<h2><a class="header" href="#summary-2" id="summary-2">Summary</a></h2>
<p>We have just created our first combinator! It takes a parser and transforms
its result into something different.</p>
<h2><a class="header" href="#exercises-6" id="exercises-6">Exercises</a></h2>
<ol>
<li>Implement the <code>Map</code> parser.</li>
<li>Write some tests to check your implementation.</li>
</ol>
<h1><a class="header" href="#between" id="between">Between</a></h1>
<p>We are capable of parsing, but all the parsers we have seen
only parse a single character. Let's say we want to parse a
number instead of a single digit.</p>
<p>For that we our going to look at the <code>Between</code> parser. We
expect it to work like the following.</p>
<pre><code>    #[test]
    fn parse_between_2_and_4_digits() {
        let input = &quot;12345&quot;;
        let parser = between(2, 4, any(|c: char| c.is_ascii_digit()));

        let actual = parser.parse(input);

        let expected = Ok((vec!['1', '2', '3', '4'], &quot;5&quot;));
        assert_eq!(actual, expected);
    }
</code></pre>
<h2><a class="header" href="#considerations" id="considerations">Considerations</a></h2>
<p>By now the strategy to creating a parser is not new. Now we have
to think about what we need to represent this parser. We need
some sort of lower bound, an upper bound and a parser that we
want to parse between the lower and upper bound times.</p>
<p>The lower bound can be just a number. Because you can not parse
less than zero times, negative numbers are not necessary. The type
for the lower bound can be any unsigned number. We will settle for
<code>u8</code>.</p>
<p>The upper bound is a little trickier. There is no natural limit,
we could be interested in all characters that match a certain parser.</p>
<p>To accomadate this we are going to introduce a custom enum <code>Limit</code>.</p>
<pre><code>pub enum Limit {
  At(u8),
  Infinity,
}
</code></pre>
<p>This way we can specify either an unlimited bound, or a bound at a
specific value.</p>
<p>Because we likely will want to check if the upper bound is reached,
we introduce a method that allows use to check that.</p>
<pre><code>impl Limit {
  pub fn is_bigger_then(&amp;self, n: u8) -&gt; bool {
    match self {
      Limit::At(threshold) =&gt; threshold &gt; &amp;n,

      Limit::Infinity =&gt; true,
    }
  }
}
</code></pre>
<p>That are almost all the considerations for the <code>Between</code> struct we
need. Let's see if you can come up with an implementation. Do note
that you probably need to think about <code>PhantomData</code> at some point.</p>
<h2><a class="header" href="#impl-parser-4" id="impl-parser-4">Impl Parser</a></h2>
<p>So we have a struct that tracks the lower limit, the upper limit and
the base parser. The implementation strategy is.</p>
<ol>
<li>Try to parse as many as the lower limit of items, accumulating the
result.</li>
<li>If that fails, report the error.</li>
<li>If it succeeds, go on to the optional phase.</li>
<li>Try to parse up to the upper limit of items.</li>
<li>If that fails, cut your losses and return the accumulated result.</li>
<li>If that succeeds, return the accumulated result. </li>
</ol>
<h2><a class="header" href="#constructor--factory-1" id="constructor--factory-1">Constructor &amp; Factory</a></h2>
<p>Create an appropriate constructor and factories. See the exercises
for some factory suggestions.</p>
<h2><a class="header" href="#summary-3" id="summary-3">Summary</a></h2>
<p>This combinator is very versatile. It can accomodate a lot of different
scenarios, depending on how you construct it. Writing factories that
reflect your needs is always a good strategy.</p>
<p>On should write code that one wants and write implementations to make
that happen.</p>
<h2><a class="header" href="#exercises-7" id="exercises-7">Exercises</a></h2>
<ol>
<li>Implement the <code>Between</code> parser.</li>
<li>Write some tests to check your implementation.</li>
<li>Introduce some other factories in terms of <code>Between</code></li>
</ol>
<ul>
<li><code>atleast</code>, will parse at least a certain number of items, but
tries to parse as many as it can from the input.</li>
<li><code>many</code>, will parse as many items as it can from the input.</li>
</ul>
<ol start="4">
<li>Think and discuss how to do better error reporting. Implement
your strategy.</li>
</ol>
<h1><a class="header" href="#oneof" id="oneof">OneOf</a></h1>
<p>Sometimes you want to have a choice. E.g. an expression could either be a number
or a variable. So when parsing an expression you want the option to parse one of
a number or variable.</p>
<p>This is where the <code>OneOf</code> parser comes in. It will pass the following test.</p>
<pre><code>    #[test]
    fn parse_one_of_a_or_b() {
        let input = &quot;a1&quot;;
        let parser = one_of(vec![character('a'), character('b')]);

        let actual = parser.parse(input);

        let expected = Ok(('a', &quot;1&quot;));
        assert_eq!(actual, expected);
    }
</code></pre>
<h2><a class="header" href="#considerations-1" id="considerations-1">Considerations</a></h2>
<p>Since the <code>Parser</code> trait can return only a single thing, all of our options in
the <code>OneOf</code> parser should adhere to the same contract.</p>
<h2><a class="header" href="#impl-parser-5" id="impl-parser-5">Impl Parser</a></h2>
<p>Once you have your options our parse strategy would be to try each of our
options in turn until one of them succeed. If it succeed return the parsed
result and the remaining input. If none of the options succeed, report an error.</p>
<h2><a class="header" href="#constructor--factories" id="constructor--factories">Constructor &amp; Factories</a></h2>
<p>Since there is not very much going on with constructors or factories. From now
on we will not mention them any more.</p>
<h2><a class="header" href="#exercises-8" id="exercises-8">Exercises</a></h2>
<ol>
<li>Implement the <code>OneOf</code> parser.</li>
<li>Write some test to check your implementation.</li>
<li>Think and discuss to do better error handling.</li>
</ol>
<h1><a class="header" href="#utilities" id="utilities">Utilities</a></h1>
<p>This chapter introduces some convenient parsers that we will use when we will be
parsing more complex structures.</p>
<h2><a class="header" href="#skip" id="skip">skip</a></h2>
<p>You are not always interested in what you are parsing. Whitespace is a good
example. The <code>skip</code> factory creates a parser that allows you to transform a
parser into one that ignores the result.</p>
<pre><code>    #[test]
    fn parse_skip_many_spaces() {
        let input = &quot;           next&quot;;
        let parser = skip(many(character(' ')));

        let actual = parser.parse(input);

        let expected = Ok(((), &quot;next&quot;));
        assert_eq!(actual, expected);
    }
</code></pre>
<p>An implementation can be given in terms of the primitives and the combinators
already given.</p>
<h2><a class="header" href="#space--spaces" id="space--spaces">space &amp; spaces</a></h2>
<p>A useful building block, to ignore, are white space. The following would be a
nice addition to our utility belt. </p>
<pre><code>    #[test]
    fn parse_spaces() {
        let input = &quot;           \tnext&quot;;
        let parser = spaces();

        let actual = parser.parse(input);

        let expected = Ok(((), &quot;next&quot;));
        assert_eq!(actual, expected);
    }
</code></pre>
<p>Don't forget about the fact that a <em>tab</em> character also counts as white space.</p>
<h2><a class="header" href="#exercises-9" id="exercises-9">Exercises</a></h2>
<ol>
<li>Implement <code>skip</code> parser. Hint: take a look at <code>map</code></li>
<li>Implement <code>space</code> and <code>spaces</code> parser. Hint: don't forget about <code>skip</code>.</li>
</ol>
<h1><a class="header" href="#macros" id="macros">Macros</a></h1>
<p>We have a fair amount of basic parsers and lovely combinators for them. But
there is one thing missing. All the parsers we have so far can only parse one
thing.</p>
<p>Give a parser an input, it will try do its job, return the result and the rest
of the input. But if we want to parse complex structures, we need to be able to
proceed parsing an that rest of the input. We need to be able to chain different
parser together, one after the other.</p>
<h2><a class="header" href="#what-we-want-to-achieve" id="what-we-want-to-achieve">What we want to achieve</a></h2>
<p>Let's say we want to parse something that looks like a L-system rule. Remember,
it starts with a symbol, followed by a literal <code>=&gt;</code> and at last a sequence of
symbols.</p>
<p>What needs to be done is that we feed the remainder of one parser into the next.
Something along the lines of</p>
<pre><code>let rem = input;
let (symbol, rem) = symbol_parser.parse(rem)?
let (_, rem) = literal('=&gt;').parse(rem)?
let (production, rem) = at_least(1, symbol_parser).parse(rem)?
</code></pre>
<p>Once we have the symbol and its production we can combine them to form a rule.</p>
<p>Although this is not hard, there is a lot of plumbing that is neither
interesting or exciting. We would rather focus on chaining the parsers and
combing their results.</p>
<h2><a class="header" href="#declarative-macros" id="declarative-macros">Declarative Macros</a></h2>
<p>Rust has a great mechanism to aid in our search for expressiveness. It are
<a href="https://doc.rust-lang.org/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming">declarative macros</a>.</p>
<p>Declarative macros</p>
<blockquote>
<p>allow you to write something similar to a Rust match expression. As discussed
in Chapter 6, match expressions are control structures that take an
expression, compare the resulting value of the expression to patterns, and
then run the code associated with the matching pattern. Macros also compare a
value to patterns that are associated with particular code: in this situation,
the value is the literal Rust source code passed to the macro; the patterns
are compared with the structure of that source code; and the code associated
with each pattern, when matched, replaces the code passed to the macro. This
all happens during compilation </p>
</blockquote>
<p>They are ideal for our situation.</p>
<h1><a class="header" href="#parsing-a-sequence" id="parsing-a-sequence">Parsing a sequence</a></h1>
<p>We would like to parse a sequence of things. First this, followed by that and
finally this thing again. At the moment we have no way of describing that. Let's
remedy that.</p>
<p>What we want to achieve is to make the following test pass.</p>
<pre><code>    #[test]
    fn parse_a_sequence_of_parsers() {
        let parser = sequence!{
            let a = character('A'),
            let b = character('b')
            =&gt;
            (a, b)
        };

        let (result, rem) = parser.parse(&quot;Ab&quot;).expect(&quot;failed to parse&quot;);
        
        assert_eq!(('A', 'b'), result);
        assert!(rem.is_empty());
    }
</code></pre>
<h2><a class="header" href="#what-do-we-want" id="what-do-we-want">What do we want</a></h2>
<p>As stated in the Macros chapter, we want to sequence parsers without having to
write all the boilerplate. As detailed in the test code above, we want to focus
on the result of parsers and combine those results in interesting ways.</p>
<p>The pattern that we picked is, one or more lines of</p>
<pre><code>let identifier = parser,
</code></pre>
<p>We would like to translate the above lines into something like</p>
<pre><code>let (identifier, remainder) = parser.parse(remainder)?
</code></pre>
<p>I.e. pass the remaining input to the parser to parse, collect the result and
bind it to the identifier and rebind the remainder.</p>
<p>Once all the parser sequences have done their job, we would like to collect all
the parse results in some meaningful manner. E.g. if we have parsed an <code>'A'</code>
followed by a <code>'b'</code>, we would return a tuple containing both results. More
general we want to return some form of expression involving the parse results.</p>
<h2><a class="header" href="#macros-to-the-rescue" id="macros-to-the-rescue">Macros to the rescue</a></h2>
<p>Luckily macros are well suited for the task. Look at the following code. We will
explain it in detail.</p>
<pre><code>#[macro_export]
macro_rules! sequence {
    ( $(let $name:ident = $parser:expr),+ =&gt; $finish:expr ) =&gt; {{
        |input| {
            let rem = input;
            $(
                let ($name, rem) = $parser.parse(rem)?;
            )*
            let result = $finish;
            Ok((result, rem))
        }
    }};
}
</code></pre>
<h3><a class="header" href="#macro_export-attribute" id="macro_export-attribute"><code>macro_export</code> attribute</a></h3>
<p>Let's start at the top. The <code>macro_export</code> attribute tells us that we would like
to make this macro available whenever the crate is in scope.</p>
<h3><a class="header" href="#macro_rules-macro" id="macro_rules-macro"><code>macro_rules!</code> macro</a></h3>
<p>The way to define a macro is by using the <code>macro_rule</code> macro. It will accept a
name and shapes that the macro should accepts and how they are translated.</p>
<p>In our case are creating a macro called <code>sequence</code>.</p>
<h3><a class="header" href="#the-pattern" id="the-pattern">The pattern</a></h3>
<p>The pattern our macro accepts is defined next. It is </p>
<pre><code>( $(let $name:ident = $parser:expr),+ =&gt; $finish:expr )
</code></pre>
<p>First let's focus on <code>let $name:ident = $parser:expr</code>. It expresses how we want
to string a results of parser. This pattern will try to match expressions like</p>
<pre><code>let a = character('A')
</code></pre>
<p>first the literal <code>let</code> next something that looks like an identifier, <code>a</code> in this
case. if it succeeds bind the identifier to the <code>$name</code> variable. Next comes a
literal <code>=</code> followed by something that looks like any Rust expression,
<code>characcter('A')</code> in our example, and bind that expression to the <code>$parser</code>
variable.</p>
<p>Notice that that entire pattern is surrounded by <code>$( ),+</code>. The plus tells us
that we need at least one, but are allowed more repetition of what ever pattern
is between the brackets, separated by an (final optional) comma.</p>
<p>Next there is a literal <code>=&gt;</code> followed by something that looks like any rust
expression. If that matches bind the expression to the <code>$finish</code> expression.</p>
<h3><a class="header" href="#the-substitutions" id="the-substitutions">The substitutions</a></h3>
<p>Declarative macros in Rust work by taking the pattern and providing a
substitution, that needs to adhere to some rules. </p>
<pre><code>    {{
        |input| {
            let rem = input;
            $(
                let ($name, rem) = $parser.parse(rem)?;
            )*
            let result = $finish;
            Ok((result, rem))
        }
    }};
</code></pre>
<p>Now this substitution will be replaced with the data that is gathered when
matching the syntax. We notice that it will return a lambda expression that
accepts input, and returns a pair of result and the remaining input. I.e. it is
a parser.</p>
<p>What is returned is in effect handled by 
</p>
<pre><code>            $(
                let ($name, rem) = $parser.parse(rem)?;
            )*
</code></pre>
<p>The <code>$( )*</code> will output its contents for each of the matching parts.</p>
<h2><a class="header" href="#exercises-10" id="exercises-10">Exercises</a></h2>
<ol>
<li>Implement and test the <code>sequence!</code> macro.</li>
<li>Often white space is not that interesting. Create a macro that allows and
ignores whitespace between the different parsers.</li>
</ol>
<h1><a class="header" href="#use-the-framework" id="use-the-framework">Use the framework</a></h1>
<p>We have created a parser combinator framework that allows us to create a parser
that parses the L-systems by combining primitive parser into more elaborate
parsers.</p>
<p>In this chapter we will work towards that goal.</p>
<h1><a class="header" href="#interpreter-1" id="interpreter-1">Interpreter</a></h1>
<p>In the Parser section we created a parser for <code>.ls</code> files that could return a
L-system data structure. We would now like to interpret this data structure in
order to evolve the L-system a number of iterations.</p>
<p>The Interpreter section will guide use along that path and describes how to
create software that can interpret our L-system and evolve the start word.</p>
<p>Make sure to look in to <a href="dependencies.html">working with dependencies</a> to find out
how to incorporate your code into the project.</p>
<h1><a class="header" href="#what-is-an-interpreter" id="what-is-an-interpreter">What is an Interpreter</a></h1>
<h1><a class="header" href="#renderer-1" id="renderer-1">Renderer</a></h1>
<p>With a working parser and interpreter for L-systems, it is time to work on
rendering. Rendering concerns itself providing a translation between the 
L-systems words that occur from the start word and some kind of visualization.</p>
<p>Make sure to look in to <a href="dependencies.html">working with dependencies</a> to find out
how to incorporate your code into the project.</p>
<h1><a class="header" href="#what-is-a-renderer" id="what-is-a-renderer">What is a Renderer</a></h1>
<h1><a class="header" href="#why-stop-here" id="why-stop-here">Why stop here</a></h1>
<p>You have done something awesome! You have explored the wonderful world of
L-systems. You have created software to be able explore interesting aspects of
L-systems, parsers, interpreters and how they interact.</p>
<p>But known this is only a tip of the iceberg. There are a lot of things to
explore further. And this chapter is shining some light into the adventurous
world of exploration.</p>
<p>Don't take it as a travelers guide. We ourselves are as oblivious as the next
person when it comes to what you want to delve into. Feel free to follow your
own interest and amaze us with your thoughts and creations.</p>
<h1><a class="header" href="#working-with-dependencies" id="working-with-dependencies">Working with Dependencies</a></h1>
<p>There are two different goals for this workshop. First is to allow you to play
with L-systems. Second is to allow you to code your own L-system, and then play
with that.</p>
<p>In order to facilitate that the code makes use of path dependencies. That way we
use can easily transition from relying on provided code to relying on your own
code.</p>
<h2><a class="header" href="#mechanism" id="mechanism">Mechanism</a></h2>
<p>If you take a look at the <code>Cargo.toml</code> file you will notice the <code>[dependencies]</code>
table has a lot of path dependencies. E.g. we have a dependency on <code>parser</code>
which can be found at <code>examplar-parser</code>, according to the following snippet.</p>
<pre><code class="language-toml">[dependencies]
parser = { path = &quot;examplar-parser&quot; }
</code></pre>
<h3><a class="header" href="#your-code" id="your-code">Your code</a></h3>
<p>Every <code>examplar-*</code> library has a regular counter-part. I.e. besides
<code>examplar-parser</code> there is also <code>parser</code> library. This library has some skeletal
code. It is an ideal starting ground for working on your own code.</p>
<h3><a class="header" href="#hooking-up-your-code" id="hooking-up-your-code">Hooking up your code</a></h3>
<p>Once you are comfortable with your code, it is time to hook it up to the main
executable. This way you can play with your own L-system.</p>
<p>This is done by changing the top-level <code>Cargo.toml</code>. Specifically the
<code>[dependencies]</code> table. For the <code>[dependencies]</code> you need to point to the correct
path. E.g. for the parser dependency the path should be <code>parser</code> if you want to
use your own code. </p>
<h3><a class="header" href="#enjoy-your-l-system" id="enjoy-your-l-system">Enjoy your L-System</a></h3>
<p>If everything works out, you should be able to enjoy your own L-system
framework.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
